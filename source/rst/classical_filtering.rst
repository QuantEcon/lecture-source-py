.. _classical_filtering:

.. include:: /_static/includes/header.raw

.. highlight:: python3


********************************************************
Classical Prediction and Filtering With Linear Algebra
********************************************************

.. contents:: :depth: 2



Overview
============



This is a sequel to the earlier lecture :doc:`Classical Control with Linear Algebra <lu_tricks>`.

That lecture used linear algebra -- in particular,  the `LU decomposition <https://en.wikipedia.org/wiki/LU_decomposition>`_  -- to formulate and solve a class of linear-quadratic optimal control problems.

In this lecture, we'll be using a closely related decomposition,
the `Cholesky decomposition <https://en.wikipedia.org/wiki/Cholesky_decomposition>`_, to solve linear prediction and filtering problems.

We exploit the useful fact that there is an intimate connection between two superficially different classes of problems:

*  deterministic linear-quadratic (LQ) optimal control problems

*  linear least squares prediction and filtering problems

The first class of problems involves no randomness, while the second is all about randomness.

Nevertheless,  essentially the same mathematics  solves both types of problem.

This connection, which is often termed "duality," is present whether one uses "classical" or "recursive" solution procedures.

In fact, we saw duality at work earlier when we formulated control and prediction problems recursively in lectures :doc:`LQ dynamic programming problems<lqcontrol>`, :doc:`A first look at the Kalman filter<kalman>`, and :doc:`The permanent income model<perm_income>`.

A useful consequence of duality is that

* With every LQ control problem, there is implicitly affiliated a linear least squares prediction or filtering problem.

* With every linear least squares prediction or filtering problem there is implicitly affiliated a LQ control problem.

An understanding of these connections has repeatedly proved useful in cracking interesting applied problems.

For example, Sargent :cite:`Sargent1987` [chs. IX, XIV] and Hansen and Sargent :cite:`HanSar1980` formulated
and solved control and filtering problems using :math:`z`-transform methods.

In this lecture, we begin to investigate these ideas by using mostly elementary linear algebra.

This is the main purpose and focus of the lecture.

However, after showing matrix algebra formulas, we'll summarize classic infinite-horizon formulas built on :math:`z`-transform  and lag
operator methods.

And we'll occasionally refer to some of these formulas from the infinite dimensional problems as we present the finite time
formulas and associated linear algebra.


We'll start with the following standard import:

.. code-block:: ipython

    import numpy as np


References
-------------

Useful references include :cite:`Whittle1963`, :cite:`HanSar1980`, :cite:`Orfanidisoptimum1988`, :cite:`Athanasios1991`, and :cite:`Muth1960`.







Finite Dimensional Prediction
===============================

Let :math:`(x_1, x_2, \ldots, x_T)^\prime = x` be a :math:`T \times 1` vector of random variables with mean :math:`\mathbb{E} x = 0` and covariance matrix :math:`\mathbb{E} xx^\prime = V`.

Here :math:`V` is a :math:`T \times T` positive definite matrix.

The :math:`i,j` component :math:`E x_i x_j` of :math:`V` is the **inner product**   between :math:`x_i` and :math:`x_j`.

We regard the random variables as being
ordered in time so that :math:`x_t` is thought of as the value of some
economic variable at time :math:`t`.

For example, :math:`x_t` could be generated by the random process described  by the Wold representation presented in equation :eq:`eq_31`
in the section below on infinite dimensional prediction and filtering.

In that case, :math:`V_{ij}` is given by the coefficient on :math:`z^{\mid i-j \mid}` in the expansion of :math:`g_x (z) = d(z) \, d(z^{-1}) + h`, which equals
:math:`h+\sum^\infty_{k=0} d_k d_{k+\mid i-j \mid}`.

We want to  construct :math:`j` step ahead linear least squares predictors of the form

.. math::

    \mathbb{\hat E}
    \left[
        x_T\vert x_{T-j}, x_{T-j + 1}, \ldots, x_1
    \right]


where :math:`\mathbb{\hat E}` is the linear least squares projection operator.

(Sometimes :math:`\mathbb{\hat E}` is called the wide-sense expectations operator)

To find linear least squares predictors it is helpful  first to construct a :math:`T \times 1` vector :math:`\varepsilon`
of random variables that form an orthonormal basis   for the vector of random variables :math:`x`.

The key insight here comes from noting that because the covariance matrix :math:`V` of :math:`x` is a positive definite and symmetric,
there exists a (Cholesky) decomposition of :math:`V` such that

.. math::

    V = L^{-1} (L^{-1})^\prime


and

.. math::

    L \, V \, L^\prime = I


where :math:`L`  and :math:`L^{-1}` are both lower triangular.

Form the :math:`T \times 1` random vector :math:`\varepsilon = Lx`.

The random vector :math:`\varepsilon` is an orthonormal basis for :math:`x` because

-  :math:`L` is nonsingular

-  :math:`\mathbb{E} \, \varepsilon \, \varepsilon^\prime = L \mathbb{E} xx^\prime L^\prime = I`

-  :math:`x = L^{-1} \varepsilon`

It is enlightening  to write out and interpret the equations :math:`Lx = \varepsilon` and :math:`L^{-1} \varepsilon = x`.

First, we'll write :math:`Lx = \varepsilon`

.. math::
    :label: eq_53

    \begin{aligned}
        L_{11} x_1 &= \varepsilon_1 \\
        L_{21}x_1 + L_{22} x_2 &= \varepsilon_2 \\ \, \vdots \\
        L_{T1} \, x_1 \, \ldots \, + L_{TT} x_T &= \varepsilon_T
    \end{aligned}


or

.. math::
    :label: eq_54

    \sum^{t-1}_{j=0} L_{t,t-j}\, x_{t-j} = \varepsilon_t, \quad t = 1, \, 2, \ldots T



Next, we write :math:`L^{-1} \varepsilon = x`


.. math::
    :label: eq_55a

    \begin{aligned}
         x_1 &= L_{11}^{-1} \varepsilon_1 \\
         x_2 &= L_{22}^{-1} \varepsilon_2 + L_{21}^{-1} \varepsilon_1  \\ \, \vdots \\
         x_T &=  L_{TT}^{-1} \varepsilon_T + L_{T,T-1}^{-1} \varepsilon_{T-1} \, \ldots \, + L_{T,1}^{-1} \varepsilon_1
    \end{aligned},




or

.. math::
    :label: eq_55

    x_t = \sum^{t-1}_{j=0} L^{-1}_{t,t-j}\, \varepsilon_{t-j}\

where :math:`L^{-1}_{i,j}` denotes the :math:`i,j` element of :math:`L^{-1}`.


From :eq:`eq_54`, it follows that :math:`\varepsilon_t` is in the linear subspace spanned by :math:`x_t,\, x_{t-1}, \ldots,\, x_1`.



From :eq:`eq_55` it follows that  that :math:`x_t` is in the linear subspace spanned by
:math:`\varepsilon_t, \, \varepsilon_{t-1}, \ldots, \varepsilon_1`.


Equation :eq:`eq_54` forms  a sequence of **autoregressions**  that for :math:`t = 1, \ldots, T` express
:math:`x_t`  as linear functions of :math:`x_s, s = 1, \ldots, t-1` and a random variable :math:`(L_{t,t})^{-1} \varepsilon_t`
that is orthogonal to each componenent of :math:`x_s, s = 1, \ldots, t-1`.

(Here :math:`(L_{t,t})^{-1}` denotes the reciprocal of :math:`L_{t,t}` while :math:`L_{t,t}^{-1}` denotes the :math:`t,t` element
of :math:`L^{-1}`).

The equivalence of the subspaces spanned by :math:`\varepsilon_t, \ldots, \varepsilon_1` and :math:`x_t, \ldots, x_1` means that
for :math:`t-1\geq m \geq 1`

.. math::
    :label: eq_56

    \mathbb{\hat E}
    [ x_t \mid x_{t-m},\, x_{t-m-1}, \ldots, x_1 ] =
    \mathbb{\hat E}
    [x_t \mid \varepsilon_{t-m}, \varepsilon_{t-m-1},\ldots, \varepsilon_1]


To proceed, it is useful to drill down and note that for :math:`t-1 \geq m \geq 1` we can  rewrite :eq:`eq_55`  in the form of the
**moving average representation**

.. math::
    :label: eq_57

    x_t = \sum^{m-1}_{j=0} L_{t,t-j}^{-1}\, \varepsilon_{t-j} + \sum^{t-1}_{j=m}
    L^{-1}_{t, t-j}\, \varepsilon_{t-j}


Representation :eq:`eq_57`  is an orthogonal decomposition of :math:`x_t` into a part :math:`\sum^{t-1}_{j=m} L_{t, t-j}^{-1}\, \varepsilon_{t-j}`
that lies in the space spanned by :math:`[x_{t-m},\, x_{t-m+1},\, \ldots, x_1]` and an orthogonal component
:math:`\sum^{t-1}_{j=m} L^{-1}_{t, t-j}\, \varepsilon_{t-j}` that does not line in that space but instead in a linear space knowns as its **orthogonal complement**.

It follows that

.. math::

    \mathbb{\hat E}  [ x_t \mid x_{t-m},\, x_{t-m-1}, \ldots, x_1 ] =  \sum^{m-1}_{j=0} L_{t,t-j}^{-1}\, \varepsilon_{t-j}

Implementation
----------------

Code that computes solutions to  LQ control and filtering problems  using the methods described here and in :doc:`lu_tricks` can be found in the file `control_and_filter.py <https://github.com/QuantEcon/QuantEcon.lectures.code/blob/master/lu_tricks/control_and_filter.py>`__.

Here's how it looks

.. literalinclude:: /_static/lecture_specific/lu_tricks/control_and_filter.py

Let's use this code to tackle two interesting examples.


Example 1
-----------


Consider a stochastic process with moving average representation

.. math::

    x_t = (1 - 2 L) \varepsilon_t


where :math:`\varepsilon_t` is a serially uncorrelated random process with mean zero and variance unity.

If we were to use the tools associated with infinite dimensional prediction and filtering to be described below,
we would use the Wiener-Kolmogorov formula :eq:`eq_36` to compute the linear least squares forecasts :math:`\mathbb{E} [x_{t+j} \mid x_t, x_{t-1}, \ldots]`, for :math:`j = 1,\, 2`.

But we can do everything we want by instead using our finite dimensional tools and
setting :math:`d = r`, generating an instance of `LQFilter`, then invoking pertinent methods of `LQFilter`.



.. code-block:: python3

    m = 1
    y_m = np.asarray([.0]).reshape(m, 1)
    d = np.asarray([1, -2])
    r = np.asarray([1, -2])
    h = 0.0
    example = LQFilter(d, h, y_m, r=d)



The Wold representation is computed by `example.coefficients_of_c()`.

Let's check that it "flips roots" as required



.. code-block:: python3

    example.coeffs_of_c()

.. code-block:: python3

    example.roots_of_characteristic()



Now let's form the covariance matrix of a time series vector of length :math:`N`
and put it in :math:`V`.

Then we'll take a Cholesky decomposition of :math:`V = L^{-1} L^{-1}` and use it to form the vector of
"moving average representations" :math:`x = L^{-1} \varepsilon` and the vector of "autoregressive representations" :math:`L x = \varepsilon`.




.. code-block:: python3

    V = example.construct_V(N=5)
    print(V)




Notice how the lower rows of the "moving average representations" are converging to the appropriate infinite history Wold representation
to be described below when we study infinite horizon-prediction and filtering



.. code-block:: python3

    Li = np.linalg.cholesky(V)
    print(Li)



Notice how the lower rows of the "autoregressive representations" are converging to the appropriate infinite-history
autoregressive representation to be described below when we study infinite horizon-prediction and filtering



.. code-block:: python3

    L = np.linalg.inv(Li)
    print(L)





Example 2
-----------

Consider a stochastic process :math:`X_t` with moving average
representation

.. math::

    X_t = (1 - \sqrt 2 L^2) \varepsilon_t


where :math:`\varepsilon_t` is a serially uncorrelated random process
with mean zero and variance unity.

Let's find a Wold moving average representation for :math:`x_t` that will prevail in the infinite-history context to be studied in
detail below.

To do this, we'll  use the Wiener-Kolomogorov formula :eq:`eq_36` presented below to compute the linear least squares forecasts
:math:`\mathbb{\hat E}\left[X_{t+j} \mid X_{t-1}, \ldots\right] \hbox { for } j = 1,\, 2,\, 3`.

We proceed in the same way as in example 1



.. code-block:: python3

    m = 2
    y_m = np.asarray([.0, .0]).reshape(m, 1)
    d = np.asarray([1, 0, -np.sqrt(2)])
    r = np.asarray([1, 0, -np.sqrt(2)])
    h = 0.0
    example = LQFilter(d, h, y_m, r=d)
    example.coeffs_of_c()

.. code-block:: python3

    example.roots_of_characteristic()

.. code-block:: python3

    V = example.construct_V(N=8)
    print(V)

.. code-block:: python3

    Li = np.linalg.cholesky(V)
    print(Li[-3:, :])

.. code-block:: python3

    L = np.linalg.inv(Li)
    print(L)








Prediction
-------------


It immediately follows from the "orthogonality principle" of least squares (see :cite:`Athanasios1991` or :cite:`Sargent1987` [ch. X]) that

.. math::
    :label: eq_58

    \begin{aligned}
        \mathbb{\hat E} & [x_t \mid x_{t-m},\, x_{t-m+1}, \ldots x_1]
                        = \sum^{t-1}_{j=m} L^{-1}_{t,t-j}\, \varepsilon_{t-j} \\
                   & = [L_{t, 1}^{-1}\, L^{-1}_{t,2},\, \ldots, L^{-1}_{t,t-m}\ 0 \ 0 \ldots 0] L \, x
    \end{aligned}


This can be interpreted as a finite-dimensional version of the Wiener-Kolmogorov :math:`m`-step ahead prediction formula.

We can use :eq:`eq_58`  to represent the linear least squares projection of
the vector :math:`x` conditioned on the first :math:`s` observations
:math:`[x_s, x_{s-1} \ldots, x_1]`.

We have

.. math::
    :label: eq_59

    \mathbb{\hat E}[x \mid x_s, x_{s-1}, \ldots, x_1]
    = L^{-1}
    \left[
        \begin{matrix}
            I_s & 0 \\
            0 & 0_{(t-s)}
        \end{matrix}
    \right] L x


This formula will be convenient in representing the solution of control problems under uncertainty.

Equation :eq:`eq_55`  can be recognized as a finite dimensional version of a moving average representation.

Equation  :eq:`eq_54` can be viewed as a finite dimension version of an autoregressive representation.

Notice that even
if the :math:`x_t` process is covariance stationary, so that :math:`V`
is such that :math:`V_{ij}` depends only on :math:`\vert i-j\vert`, the
coefficients in the moving average representation are time-dependent,
there being a different moving average for each :math:`t`.

If
:math:`x_t` is a covariance stationary process, the last row of
:math:`L^{-1}` converges to the coefficients in the Wold moving average
representation for :math:`\{ x_t\}` as :math:`T \rightarrow \infty`.

Further, if :math:`x_t` is covariance stationary, for fixed :math:`k`
and :math:`j > 0, \, L^{-1}_{T,T-j}` converges to
:math:`L^{-1}_{T-k, T-k-j}` as :math:`T \rightarrow \infty`.

That is,
the “bottom” rows of :math:`L^{-1}` converge to each other and to the
Wold moving average coefficients as :math:`T \rightarrow \infty`.

This last observation gives one simple and widely-used practical way of
forming a finite :math:`T` approximation to a Wold moving average
representation.

First, form the covariance matrix
:math:`\mathbb{E}xx^\prime = V`, then obtain the Cholesky decomposition
:math:`L^{-1} L^{-1^\prime}` of :math:`V`, which can be accomplished
quickly on a computer.

The last row of :math:`L^{-1}` gives the approximate Wold moving average coefficients.

This method can readily be generalized to multivariate systems.




.. _fdcp:

Combined Finite Dimensional Control and Prediction
====================================================



Consider the finite-dimensional control problem, maximize

.. math::

    \mathbb{E} \, \sum^N_{t=0} \,
    \left\{
         a_t y_t - {1 \over 2} h y^2_t - {1 \over 2} [d(L) y_t ]^2
    \right\},\  \quad h > 0


where :math:`d(L) = d_0 + d_1 L+ \ldots + d_m L^m`, :math:`L` is the
lag operator, :math:`\bar a = [ a_N, a_{N-1} \ldots, a_1, a_0]^\prime` a
random vector with mean zero and :math:`\mathbb{E}\,\bar a \bar a^\prime = V`.

The variables :math:`y_{-1}, \ldots, y_{-m}` are given.

Maximization is over choices of :math:`y_0,
y_1 \ldots, y_N`, where :math:`y_t` is required to be a linear function
of :math:`\{y_{t-s-1}, t+m-1\geq 0;\ a_{t-s}, t\geq s\geq 0\}`.

We saw in the lecture :doc:`Classical Control with Linear Algebra <lu_tricks>`  that the solution of this problem under certainty could be represented in the feedback-feedforward form

.. math::

    U \bar y
       = L^{-1}\bar a + K
       \left[
         \begin{matrix}
             y_{-1}\\
             \vdots\\
             y_{-m}
         \end{matrix}
       \right]


for some :math:`(N+1)\times m` matrix :math:`K`.

Using a version of formula :eq:`eq_58`, we can express :math:`\mathbb{\hat E}[\bar a \mid a_s,\, a_{s-1}, \ldots, a_0 ]` as

.. math::

    \mathbb{\hat E}
    [ \bar a \mid a_s,\, a_{s-1}, \ldots, a_0]
    = \tilde U^{-1}
    \left[
        \begin{matrix}
            0 & 0 \\
            0 & I_{(s+1)}
        \end{matrix}
    \right]
    \tilde U \bar a


where :math:`I_{(s + 1)}` is the :math:`(s+1) \times (s+1)` identity
matrix, and :math:`V = \tilde U^{-1} \tilde U^{-1^{\prime}}`, where
:math:`\tilde U` is the *upper* triangular Cholesky factor of the
covariance matrix :math:`V`.

(We have reversed the time axis in dating the :math:`a`'s relative to earlier)

The time axis can be reversed in representation :eq:`eq_59` by replacing :math:`L` with :math:`L^T`.

The optimal decision rule to use at time :math:`0 \leq t \leq N` is then
given by the :math:`(N-t +1)^{\rm th}` row of

.. math::

    U \bar y = L^{-1} \tilde U^{-1}
        \left[
            \begin{matrix}
                0 & 0 \\
                0 & I_{(t+1)}
            \end{matrix}
        \right]
        \tilde U \bar a + K
        \left[
        \begin{matrix}
            y_{-1}\\
            \vdots\\
            y_{-m}
        \end{matrix}
        \right]








Infinite Horizon Prediction and Filtering Problems
=====================================================

It is instructive to compare the finite-horizon formulas based on linear algebra decompositions of finite-dimensional covariance matrices
with classic formulas for infinite horizon and infinite history prediction and control problems.

These classic infinite horizon formulas used the mathematics of :math:`z`-transforms and lag operators.

We'll meet interesting lag operator and :math:`z`-transform  counterparts to our finite horizon matrix formulas.


We pose two related prediction and filtering problems.

We let :math:`Y_t` be a univariate :math:`m^{\rm th}` order moving average, covariance stationary stochastic process,

.. math::
    :label: eq_24

    Y_t = d(L) u_t


where :math:`d(L) = \sum^m_{j=0} d_j L^j`, and :math:`u_t` is a serially uncorrelated stationary random process satisfying

.. math::
    :label: eq_25

    \begin{aligned}
        \mathbb{E} u_t &= 0\\
        \mathbb{E} u_t u_s &=
        \begin{cases}
            1 & \text{ if } t = s \\
            0 & \text{ otherwise}
        \end{cases}
    \end{aligned}


We impose no conditions on the zeros of :math:`d(z)`.

A second covariance stationary process is :math:`X_t` given by

.. math::
    :label: eq_26

    X_t = Y_t + \varepsilon_t


where :math:`\varepsilon_t` is a serially uncorrelated stationary
random process with :math:`\mathbb{E} \varepsilon_t = 0` and :math:`\mathbb{E} \varepsilon_t \varepsilon_s` = :math:`0` for all distinct :math:`t` and :math:`s`.

We also assume that :math:`\mathbb{E} \varepsilon_t u_s = 0` for all :math:`t` and :math:`s`.

The **linear least squares prediction problem** is to find the :math:`L_2`
random variable :math:`\hat X_{t+j}` among linear combinations of
:math:`\{ X_t,\  X_{t-1},
\ldots \}` that minimizes :math:`\mathbb{E}(\hat X_{t+j} - X_{t+j})^2`.

That is, the problem is to find a :math:`\gamma_j (L) = \sum^\infty_{k=0} \gamma_{jk}\, L^k` such that :math:`\sum^\infty_{k=0} \vert \gamma_{jk} \vert^2 < \infty` and :math:`\mathbb{E} [\gamma_j \, (L) X_t -X_{t+j}]^2` is minimized.

The **linear least squares filtering problem** is to find a :math:`b\,(L) = \sum^\infty_{j=0} b_j\, L^j` such that :math:`\sum^\infty_{j=0}\vert b_j \vert^2 < \infty` and :math:`\mathbb{E} [b\, (L) X_t -Y_t ]^2` is minimized.

Interesting versions of these problems related to the permanent income theory were studied by :cite:`Muth1960`.




Problem Formulation
--------------------

These problems are solved as follows.

The covariograms of :math:`Y` and :math:`X` and their cross covariogram are, respectively,

.. math::
    :label: eq_27

    \begin{aligned}
        C_X (\tau) &= \mathbb{E}X_t X_{t-\tau} \\
        C_Y (\tau) &= \mathbb{E}Y_t Y_{t-\tau}  \qquad \tau = 0, \pm 1, \pm 2, \ldots \\
        C_{Y,X} (\tau) &= \mathbb{E}Y_t X_{t-\tau}
    \end{aligned}


The covariance and cross-covariance generating functions are defined as

.. math::
    :label: eq_28

     \begin{aligned}
        g_X(z) &= \sum^\infty_{\tau = - \infty} C_X (\tau) z^\tau \\
        g_Y(z) &= \sum^\infty_{\tau = - \infty} C_Y (\tau) z^\tau \\
        g_{YX} (z) &= \sum^\infty_{\tau = - \infty} C_{YX} (\tau) z^\tau
    \end{aligned}


The generating functions can be computed by using the following facts.

Let :math:`v_{1t}` and :math:`v_{2t}` be two mutually and serially uncorrelated white noises with unit variances.

That is, :math:`\mathbb{E}v^2_{1t} = \mathbb{E}v^2_{2t} = 1, \mathbb{E}v_{1t} = \mathbb{E}v_{2t} = 0, \mathbb{E}v_{1t} v_{2s} = 0` for all :math:`t` and :math:`s`, :math:`\mathbb{E}v_{1t} v_{1t-j} = \mathbb{E}v_{2t} v_{2t-j} = 0` for all :math:`j \not = 0`.

Let :math:`x_t` and :math:`y_t` be two random processes given by

.. math::

    \begin{aligned}
        y_t &= A(L) v_{1t} + B(L) v_{2t} \\
        x_t &= C(L) v_{1t} + D(L) v_{2t}
    \end{aligned}


Then, as shown for example in :cite:`Sargent1987` [ch. XI], it is true that

.. math::
    :label: eq_29

    \begin{aligned}
        g_y(z) &= A(z) A(z^{-1}) + B (z) B(z^{-1}) \\
        g_x (z) &= C(z) C(z^{-1}) + D(z) D(z^{-1}) \\
        g_{yx} (z) &= A(z) C(z^{-1}) + B(z) D(z^{-1})
    \end{aligned}


Applying these formulas to :eq:`eq_24` -- :eq:`eq_27`, we have

.. math::
    :label: eq_30

    \begin{aligned}
        g_Y(z) &= d(z)d(z^{-1}) \\
        g_X(z) &= d(z)d(z^{-1}) + h\\
        g_{YX} (z) &= d(z) d(z^{-1})
    \end{aligned}


The key step in obtaining solutions to our problems is to factor the covariance generating function  :math:`g_X(z)` of :math:`X`.

The solutions of our problems are given by formulas due to Wiener and Kolmogorov.

These formulas utilize the Wold moving average representation of the :math:`X_t` process,

.. math::
    :label: eq_31

    X_t = c\,(L)\,\eta_t


where :math:`c(L) = \sum^m_{j=0} c_j\, L^j`, with

.. math::
    :label: eq_32

    c_0 \eta_t
    = X_t - \mathbb{\hat E} [X_t \vert X_{t-1}, X_{t-2}, \ldots]


Here :math:`\mathbb{\hat E}` is the linear least squares projection operator.

Equation :eq:`eq_32`  is the condition that :math:`c_0 \eta_t` can be the one-step-ahead error in predicting :math:`X_t` from its own past values.

Condition :eq:`eq_32`  requires that :math:`\eta_t` lie in the closed
linear space spanned by :math:`[X_t,\  X_{t-1}, \ldots]`.

This will be true if and only if the zeros of :math:`c(z)` do not lie inside the unit circle.

It is an implication of :eq:`eq_32` that :math:`\eta_t` is a serially
uncorrelated random process and that normalization can be imposed so
that :math:`\mathbb{E}\eta_t^2 = 1`.

Consequently, an implication of :eq:`eq_31`  is
that the covariance generating function of :math:`X_t` can be expressed
as

.. math::
    :label: eq_33

    g_X(z) = c\,(z)\,c\,(z^{-1})


It remains to discuss how :math:`c(L)` is to be computed.

Combining :eq:`eq_29`  and :eq:`eq_33`  gives

.. math::
    :label: eq_34

    d(z) \,d(z^{-1}) + h = c \, (z) \,c\,(z^{-1})


.. An identical equation :ref:`can be found <oneeight_ref>` in the lecture :doc:`lu_tricks`.

.. Add the next sentence once Sphinx starts supporting cross file equation references (due in next release).

.. Further, the conditions that :eq:`eq_31`  imposes on :math:`c(z)`, that its zeros not lie inside the unit circle, are analogous with those imposed in  equation (17) in lecture :doc:`lu_tricks`.

Therefore, we have already shown constructively how to factor the covariance generating function :math:`g_X(z) = d(z)\,d\,(z^{-1}) + h`.

We now introduce the **annihilation operator**:

.. math::
    :label: eq_35

    \left[
        \sum^\infty_{j= - \infty} f_j\, L^j
    \right]_+
    \equiv \sum^\infty_{j=0} f_j\,L^j


In words, :math:`[\phantom{00}]_+` means "ignore negative powers of :math:`L`".

We have defined the solution of the prediction problem as :math:`\mathbb{\hat E} [X_{t+j} \vert X_t,\, X_{t-1}, \ldots] = \gamma_j\, (L) X_t`.

Assuming that the roots of :math:`c(z) = 0` all lie outside the unit circle, the Wiener-Kolmogorov formula for :math:`\gamma_j (L)` holds:

.. math::
    :label: eq_36

    \gamma_j\, (L) =
    \left[
        {c (L) \over L^j}
    \right]_+ c\,(L)^{-1}


We have defined the solution of the filtering problem as :math:`\mathbb{\hat E}[Y_t \mid X_t, X_{t-1}, \ldots] = b (L)X_t`.

The Wiener-Kolomogorov formula for :math:`b(L)` is

.. math::

    b(L) = \left[{g_{YX} (L) \over c(L^{-1})}\right]_+ c(L)^{-1}


or

.. math::
    :label: eq_37

    b(L) = \left[ {d(L)d(L^{-1}) \over c(L^{-1})} \right]_+ c(L)^{-1}


Formulas :eq:`eq_36` and :eq:`eq_37`  are discussed in detail in  :cite:`Whittle1983` and :cite:`Sargent1987`.

The interested reader can there find several examples of the use of these formulas in economics
Some classic examples using these formulas are due to :cite:`Muth1960`.

As an example of the usefulness of formula :eq:`eq_37`, we let :math:`X_t` be a stochastic process with Wold moving average representation

.. math::

    X_t = c(L) \eta_t


where :math:`\mathbb{E}\eta^2_t = 1, \hbox { and } c_0 \eta_t = X_t - \mathbb{\hat E} [X_t \vert X_{t-1}, \ldots], c (L) = \sum^m_{j=0} c_j L`.

Suppose that at time :math:`t`, we wish to predict a geometric sum of future :math:`X`'s, namely

.. math::

    y_t \equiv \sum^\infty_{j=0} \delta^j X_{t+j} = {1 \over 1 - \delta L^{-1}}
    X_t


given knowledge of :math:`X_t, X_{t-1}, \ldots`.

We shall use :eq:`eq_37`  to obtain the answer.

Using the standard formulas  :eq:`eq_29`, we have that

.. math::

    \begin{aligned}
        g_{yx}(z) &= (1-\delta z^{-1})c(z) c (z^{-1}) \\
        g_x (z) &= c(z) c (z^{-1})
    \end{aligned}


Then :eq:`eq_37`  becomes

.. math::
    :label: eq_38

    b(L)=\left[{c(L)\over 1-\delta L^{-1}}\right]_+ c(L)^{-1}


In order to evaluate the term in the annihilation operator, we use the following result from :cite:`HanSar1980`.




**Proposition** Let

* :math:`g(z) = \sum^\infty_{j=0} g_j \, z^j` where :math:`\sum^\infty_{j=0} \vert g_j \vert^2 < + \infty`.

* :math:`h\,(z^{-1}) =` :math:`(1- \delta_1 z^{-1}) \ldots (1-\delta_n z^{-1})`, where :math:`\vert \delta_j \vert < 1`, for :math:`j = 1, \ldots, n`.

Then

.. math::
    :label: eq_39

    \left[{g(z)\over h(z^{-1})}\right]_+ = {g(z)\over h(z^{-1})} - \sum^n_{j=1}
    \ {\delta_j g (\delta_j) \over \prod^n_{k=1 \atop k \not = j} (\delta_j -
    \delta_k)} \ \left({1 \over z- \delta_j}\right)


and, alternatively,

.. math::
    :label: eq_40

    \left[
        {g(z)\over h(z^{-1})}
    \right]_+
    =\sum^n_{j=1} B_j
    \left(
        {zg(z)-\delta_j g (\delta_j) \over z- \delta_j}
    \right)


where :math:`B_j = 1 / \prod^n_{k=1\atop k+j} (1 - \delta_k / \delta_j)`.

Applying formula :eq:`eq_40`  of the proposition to evaluating  :eq:`eq_38`  with :math:`g(z) = c(z)` and :math:`h(z^{-1}) = 1 - \delta z^{-1}` gives

.. math::

    b(L)=\left[{Lc(L)-\delta c(\delta)\over L-\delta}\right] c(L)^{-1}


or

.. math::

    b(L) =
    \left[
        {1-\delta c (\delta) L^{-1} c (L)^{-1}\over 1-\delta L^{-1}}
    \right]


Thus, we have

.. math::
    :label: eq_41

    \mathbb{\hat E}
    \left[
        \sum^\infty_{j=0} \delta^j X_{t+j}\vert X_t,\, x_{t-1},
        \ldots
    \right] =
    \left[
        {1-\delta c (\delta) L^{-1} c(L)^{-1} \over 1 - \delta L^{-1}}
    \right]
    \, X_t


This formula is useful in solving stochastic versions of problem 1 of lecture :doc:`lu_tricks` in which the randomness emerges because :math:`\{a_t\}` is a stochastic
process.

The problem is to maximize

.. math::
    :label: eq_42

    \mathbb{E}_0
    \lim_{N \rightarrow \infty}\
    \sum^N_{t-0} \beta^t
    \left[
        a_t\, y_t - {1 \over 2}\ hy^2_t-{1 \over 2}\ [d(L)y_t]^2
    \right]


where :math:`\mathbb{E}_t` is mathematical expectation conditioned on information
known at :math:`t`, and where :math:`\{ a_t\}` is a covariance
stationary stochastic process with Wold moving average representation

.. math::

    a_t = c(L)\, \eta_t


where

.. math::

    c(L) = \sum^{\tilde n}_{j=0} c_j L^j


and

.. math::

    \eta_t =
    a_t - \mathbb{\hat E} [a_t \vert a_{t-1}, \ldots]


The problem is to maximize :eq:`eq_42`  with respect to a contingency plan
expressing :math:`y_t` as a function of information known at :math:`t`,
which is assumed to be
:math:`(y_{t-1},\  y_{t-2}, \ldots, a_t, \ a_{t-1}, \ldots)`.

The solution of this problem can be achieved in two steps.

First, ignoring the uncertainty, we can solve the problem assuming that :math:`\{a_t\}` is a known sequence.

The solution is, from above,

.. math::

    c(L) y_t = c(\beta L^{-1})^{-1} a_t


or

.. math::
    :label: eq_43

    (1-\lambda_1 L) \ldots (1 - \lambda_m L) y_t
    = \sum^m_{j=1} A_j
    \sum^\infty_{k=0} (\lambda_j \beta)^k\, a_{t+k}


Second, the solution of the problem under uncertainty is obtained by
replacing the terms on the right-hand side of the above expressions with
their linear least squares predictors.

Using :eq:`eq_41` and :eq:`eq_43`, we have
the following solution

.. math::

    (1-\lambda_1 L) \ldots (1-\lambda_m L) y_t =
    \sum^m_{j=1} A_j
     \left[
         \frac{1-\beta \lambda_j \, c (\beta \lambda_j) L^{-1} c(L)^{-1} }
         { 1-\beta \lambda_j L^{-1} }
     \right] a_t




**Blaschke factors**


The following is a useful piece of mathematics underlying "root flipping".


Let :math:`\pi (z) = \sum^m_{j=0} \pi_j z^j` and let :math:`z_1, \ldots,
z_k` be the zeros of :math:`\pi (z)` that are inside the unit circle, :math:`k < m`.

Then define

.. math::

    \theta (z) = \pi (z) \Biggl( {(z_1 z-1) \over (z-z_1)} \Biggr)
    \Biggl( { (z_2 z-1) \over (z-z_2) } \Biggr ) \ldots \Biggl({(z_kz-1) \over
    (z-z_k) }\Biggr)


The term multiplying :math:`\pi (z)` is termed a "Blaschke factor".

Then it can be proved directly that

.. math::

    \theta (z^{-1}) \theta (z) = \pi (z^{-1}) \pi (z)


and that the zeros of :math:`\theta (z)` are not inside the unit circle.



Exercises
=================



Exercise 1
-----------

Let :math:`Y_t = (1 - 2 L ) u_t` where :math:`u_t` is a mean zero
white noise with :math:`\mathbb{E} u^2_t = 1`. Let

.. math::

    X_t = Y_t + \varepsilon_t


where :math:`\varepsilon_t` is a serially uncorrelated white noise with
:math:`\mathbb{E} \varepsilon^2_t = 9`, and :math:`\mathbb{E} \varepsilon_t u_s = 0` for all
:math:`t` and :math:`s`.

Find the Wold moving average representation for :math:`X_t`.

Find a formula for the :math:`A_{1j}`'s in

.. math::

    \mathbb{E} \widehat X_{t+1} \mid X_t, X_{t-1}, \ldots = \sum^\infty_{j=0} A_{1j}
    X_{t-j}


Find a formula for the :math:`A_{2j}`'s in

.. math::

    \mathbb{\hat E} X_{t+2} \mid X_t, X_{t-1}, \ldots = \sum^\infty_{j=0} A_{2j}
    X_{t-j}


Exercise 2
------------


**Multivariable Prediction:** Let :math:`Y_t` be an :math:`(n\times 1)`
vector stochastic process with moving average representation

.. math::

    Y_t = D(L) U_t


where :math:`D(L) = \sum^m_{j=0} D_j L^J, D_j` an :math:`n \times n`
matrix, :math:`U_t` an :math:`(n \times 1)` vector white noise with
:math:`\mathbb{E} U_t =0` for all :math:`t`, :math:`\mathbb{E} U_t U_s' = 0` for all :math:`s \neq t`,
and :math:`\mathbb{E} U_t U_t' = I` for all :math:`t`.

Let :math:`\varepsilon_t` be an :math:`n \times 1` vector white noise with mean :math:`0` and contemporaneous covariance matrix :math:`H`, where :math:`H` is a positive definite matrix.

Let :math:`X_t = Y_t +\varepsilon_t`.

Define the covariograms as :math:`C_X
(\tau) = \mathbb{E} X_t X^\prime_{t-\tau}, C_Y (\tau) = \mathbb{E} Y_t Y^\prime_{t-\tau},
C_{YX} (\tau) = \mathbb{E} Y_t X^\prime_{t-\tau}`.

Then define the matrix
covariance generating function, as in :eq:`onetwenty`, only interpret all the
objects in :eq:`onetwenty` as matrices.

Show that the covariance generating functions are given by

.. math::

    \begin{aligned}
        g_y (z) &= D (z) D (z^{-1})^\prime \\
        g_X (z) &= D (z) D (z^{-1})^\prime + H \\
        g_{YX} (z) &= D (z) D (z^{-1})^\prime
    \end{aligned}


A factorization of :math:`g_X (z)` can be found (see :cite:`Rozanov1967` or :cite:`Whittle1983`) of the form

.. math::

    D (z) D (z^{-1})^\prime + H = C (z) C (z^{-1})^\prime, \quad C (z) =
    \sum^m_{j=0} C_j z^j


where the zeros of :math:`\vert C(z)\vert` do not lie inside the unit
circle.

A vector Wold moving average representation of :math:`X_t` is then

.. math::

    X_t = C(L) \eta_t


where :math:`\eta_t` is an :math:`(n\times 1)` vector white noise that
is "fundamental" for :math:`X_t`.

That is, :math:`X_t - \mathbb{\hat E}\left[X_t \mid X_{t-1}, X_{t-2}
\ldots\right] = C_0 \, \eta_t`.

The optimum predictor of :math:`X_{t+j}` is

.. math::

    \mathbb{\hat E} \left[X_{t+j} \mid X_t, X_{t-1}, \ldots\right]
     = \left[{C(L) \over L^j} \right]_+ \eta_t


If :math:`C(L)` is invertible, i.e., if the zeros of :math:`\det`
:math:`C(z)` lie strictly outside the unit circle, then this formula can
be written

.. math::
    \mathbb{\hat E} \left[X_{t+j} \mid X_t, X_{t-1}, \ldots\right]
        = \left[{C(L) \over L^J} \right]_+ C(L)^{-1}\, X_t
